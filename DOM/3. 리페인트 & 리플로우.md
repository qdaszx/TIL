# 리페인트 & 리플로우

## Reflow 란?

> ## 생성된 DOM 노드의 레이아웃 변경 시 영향을 받는 모든 노드(부모, 자식)의 수치를 다시 계산하여 레이아웃 트리(렌더 트리)를 재생성하는 작업을 말합니다.

## Reflow를 발생하게 하는 속성

- ## width, height, padding, margin, float, position 등등.. 레이아웃에 영향을 주는 모든 속성

## Repaint 란?

> ## Reflow 과정이 끝나고 재생성된 레이아웃 트리(렌더 트리)를 다시 레이어에 그리는 작업

## Repaint를 발생하게 하는 속성

- ## color, border-radius, background, box-shadow 등등.. 시각적으로 보여지는 모든 속성

## 정리하면,

## 리플로우와 리페인트는 렌더링 과정에서 레이아웃 단계와 페인트 단계를 다시(Re) 거치는 과정입니다.

---

# 그렇다면 왜 리플로우와 리페인트는 렌더링 속도에 중요한 영향을 미칠까요?

## 렌더링 과정은 순차적으로 진행됩니다.

- ## 각각의 렌더링 과정들은 반드시 전 단계의 데이터가 필요합니다.
- ## 만약 전 단계에 변화가 일어나면 다음 단계에 모두 영향을 미칩니다.

## 여러분이 요소를 왼쪽에서 오른쪽으로 이동하게 만드는 애니메이션을 만들었다고 가정하겠습니다.

- ### 해당 요소가 60fps로 움직일 때 우리 눈에 자연스러워 보일겁니다.
- ### 이때 요소의 레이아웃이 변경되기 때문에 렌더링 엔진은 60장의 프레임에 0.1초 간격으로 리플로우, 리페인트 과정을 수행해야합니다.

- ## 이 과정 중에 0.1초 안으로 리플로우, 리페인트를 끝내지 못하면 우리 눈에는 애니메이션이 버벅거리는 것처럼 보이겠죠!

## 결국 reflow, repaint 해야할 요소가 많으면 많아질 수록 자연스럽지 못한 애니메이션을 그리게 될 것이고 브라우저의 전체적인 성능에 영향을 미치게 됩니다.

---

# 해결 방법

## 1. CSS Transform 속성을 사용합니다.

- ### transform을 사용하여 만드는 애니메이션은 cpu대신 gpu를 사용하여 화면 렌더링을 처리합니다.

## CPU도 엄청나게 강력한 팔방미인이지만 이미 너무 바쁩니다 ㅜㅜ

- ### gpu는 여러개의 코어가 간단한 작업을 동시에 협업하는데 특화되어 있기 때문에 애니메이션을 빠르게 처리할 수 있습니다.

## 2. requestAnimationFrame 함수를 사용합니다.

- ### requestAnimationFrame 함수는 자바스크립트를 통해 일어나는 애니메이션 정보를 브라우저에 매 프레임마다 **미리** 알려줍니다.

## 자바스크립트 애니메이션이 프레임의 시작 시 실행되도록 보장합니다.

<img width="600" alt="스크린샷 2021-09-20 오후 7 09 26" src="https://user-images.githubusercontent.com/81012135/133986155-3ffcfe90-df92-470e-9a1e-7230c8a90439.png">

## 정리해봅시다.

- ### reflow란 생성된 DOM노드의 레이아웃 변경 시 레이아웃 트리(렌더 트리)를 재생성하는 작업을 말합니다.
- ### repaint란 Reflow 과정이 끝나고 재생성된 레이아웃 트리(렌더 트리)를 다시 레이어에 그리는 작업입니다.
- ### reflow, repaint 작업이 많아질수록 렌더링 성능이 저하됩니다.
- ### 성능 저하를 막기 위해 CSS transform, JS requestAnimationFrame 함수를 사용합니다.
