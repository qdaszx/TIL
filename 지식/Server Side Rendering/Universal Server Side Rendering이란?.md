# Universal Server Side Rendering 이란?

> 이번 포스팅에서는 최근 모던 웹 어플리케이션에서 많이 사용하고 있는 `Universal SSR`에 대해서 설명하고자 한다. `Server Side Rendering`과 `Single Page Application`의 방식을 간단하게 알아보고 이 두 렌더 방식을 조합한 `Universal SSR`의 방식을 설명한다.

## Server Side Rendering을 수행하는 Multi Page Application

`SSR` 방식은 원래 전통적인 웹 어플리케이션에서 사용하던 방식이다. 최근에 `SPA (Single Page Applitcation)`과 대조하여 `MAP(Multi Page Application)`이라고 불린다. `SSR` 어플리케이션은 라우팅이 수행된 후 새로운 페이지가 서버에 요청되고 싶으면 그때마다 HTML를 렌더한 후 클라이언트에서 전체 페이지를 다시 내려받는다.

대략적인 실행 순서는 다음과 같다.

<img width="500" alt="스크린샷 2021-09-17 오후 12 17 10" src="https://user-images.githubusercontent.com/81012135/133718688-4740ea09-53b2-4c53-9744-5c1a6c811e7f.png">

1. 클라이언트가 서버에 `example.com/products/12` URL로 요청을 보낸다.
2. 서버에서는 해당 URL과 연결되어 있는 메소드가 실행되고 알맞는 `HTML Templage`파일을 찾는다.
3. Database에서 12번 상품의 데이터를 가져온다.
4. 가져온 데이터와 `HTML Template`을 사용해 최종 `HTML`을 렌더한다.
5. 클라이언트로 `HTML`을 내려준다.
6. 최종적으로 사용자가 뷰를 본다.

- 사용자가 렌더된 페이지를 본 이후에도 `Ajax`를 사용하여 데이터를 추가로 더 받아올 수도 있겠지만 일단 사용자가 완성된 페이지를 보는 시점은 6번 과정이 끝난 이후기 때문에 `Ajax`와 같은 예외는 생략했다.

- 또한 2번 과정에서 어째서 이 방식의 어플리케이션이 `MPA`라고 불리는 지 알 수 있는데, 각 페이지에 매칭된 `HTML Template`이 따로 존재하기 때문이다. 다음과 같은 방식의 장단점은 다음과 같다.

**장점**

- 서버에서 완성된 `HTML`을 내려주기 때문에 `SEO (Search Engine Optimization)`에 최적화 되어 있다.
- 매 페이지에서 필요한 리소스만 로딩하기 때문에 초기 로딩속도를 최적화 할 수 있다.

**단점**

- 매 페이지 로딩 시마다 새로운 리소스를 요청해야하므로 전체적인 트래픽이 증가한다.
- 페이지 이동 시 마다 새로고침이 되며 전체 페이지를 다시 렌더하므로 로딩 시간이 길어진다.

## Client Side Rendering을 수행하는 Single Page Application

최근 들어 많은 수의 Frontend 개발자가 `Client Side Rendering`을 수행하는 A.K.A `SPA (Single Page Application)`를 개발한다. 즉, 서버에서 실제로 다운로드 받는 페이지는 단 1개이고 그 이후 JavaScript를 통해 동적인 렌더링을 실시하는 어플리케이션을 의미한다.

대략적인 실행 순서는 다음과 같다.

<img width="500" alt="스크린샷 2021-09-17 오후 12 25 48" src="https://user-images.githubusercontent.com/81012135/133719356-f3808325-4759-42eb-8cf2-3c24b0b49efc.png">

1. 클라이언트가 서버에 `example.com/products/12` URL로 요청을 보낸다.
2. 서버에서는 뭐가 됐던 요청 URL이 `exmplate.com`으로 시작하면 `index.html`을 찾아서 내려준다.
3. 그리고 추가로 `JavaScript Bundle`을 같이 내려준다. 예를 들면 `Webpack` 같은 모듈러로 빌드하면 나오는 `bundle.js`같은 파일이 되겠다.
4. `bundle.js`을 실행한 클라이언트가 `api.example.com/product/12` API를 사용하여 12번 상품의 데이터를 서버에 요청한다.
5. 서버는 Database에서 12번 상품의 데이터를 가져온 후 클라이언트에 데이터를 내려준다.
6. 클라이언트는 받아온 데이터를 사용하여 뷰가 렌더한다.
7. 최종적으로 사용자가 뷰를 본다.

아까에 비해서 뭔가 복잡해졌다. 이 방식이 `SPA`인 이유는 2번 과정에 있다. 보통 `Nginx`나 `Apache`같은 서버 엔진의 설정에 해당 url을 선언하고 조건에 일치하는 url로 요청이 들어왔을 경우 `index.html` 파일을 찾아서 보내준다. 어떤 url이든 조건에 일치하게 되면 `index.html` 하나만 보내주기 때문에 `Single Page`인 것이다.

그리고 클라이언트는 현재 12번 상품의 데이터를 가지고 있지 않기 때문에 추가적으로 API 호츨을 하여 12번 상품의 데이터를 받아와야 한다.

그럼 `SPA`의 장단점도 한번 살펴보자.

**장점**

- 초기 로딩 시 서버로부터 모든 정적 리소스를 내려받은 후에는 페이지 이동 시 필요한 데이터만 내려받으므로 로딩 속도가 빠르고 전체적인 트래픽을 감소시킬 수 있다.
- 페이지 이동 시 새로고침이 되지 않으므로 사용자 경험(UX)가 향상된다.

**단점**

- 초기 로딩 시 현재 페이지에서 사용하지 않는 모든 정적 리소스를 받으므로 초기 로딩 속도가 느리다.
- `SEO`에 취약하다.

## SSR vs SPA

각 방식의 대략적인 실행 흐름과 장단점을 살펴보았는데, `SSR`과 `SPA` 두 방식 모두 `로딩 속도`라는 장단점을 가지고 있다. 뭐가 다른 걸까?

`SSR`의 장점은 `초기 로딩속도`이다. `SPA`는 첫 로딩 시 전체 어플리케이션에서 사용하는 모든 정적 리소스를 내려 받기때문에 초기 로딩 속도는 느리지만 그 이후에는 추가적으로 리소를 다운로드 받을 필요가 없기 때문에 이후 구동 속도가 빠른 것이다.

반면 `SSR`은 현재 페이지에서 필요한 리소스만 로딩하면 되기 때문에 초기 로딩속도는 `SPA`에 비해서 빠를 수 있다. 그러나 받아온 정적 리소스를 어딘가에 저장하고 있는 게 아니기 때문에 페이지를 이동할 때마다 저번 페이지에서 받아왔던 리소스라고 하더라도 처음부터 다시 받아와야 한다.

그래서 어플리케이션 초기화 후 페이지 이동 시 로딩 시간은 `SSR`이 더 느릴 수 있다.

하지만 `SPA`방식의 어마무시한 단점은 바로 `SEO`다. `SEO`는 Search Engine Optimization의 약자로 직역 그대로 `검색 엔진 최적화`를 의미한다.

검색 엔진은 기본적으로 크롤링을 해서 페이지를 수집하는 방식으로 이루어져 있는데, 문제는 크롤링을 하는 봇들이 JavaScript를 실행할 수 있는 능력이 없다는 것이다.

최근 구글 크롤러 같은 경우는 JavaScript 실행 능력이 있다고 하지만 개인적으로 아직까지 그렇게까지 신뢰가 가는 정도는 아니라고 본다. 게다가 Facebook과 같은 SNS에 페이지 공유를 했을 때에는 `og meta tag`를 크롤러가 읽어야지 공유된 사이트의 정보가 올바르게 표시되는데, JavaScript가 실행되지 않은 페이지를 크롤러가 읽었을 때가 그냥 빈페이지밖에 없으니 정보를 제대로 표시해주지 못하는 문제도 있었다.

필자도 이 문제를 해결하기 위해 `#! (해쉬뱅)` 이라던가 `_esacped_fragment_` 이라던가 `Pre rendering` 같은 방법들을 사용해 봤었지만 검색엔진사에서 권장하는대로 어플리케이션을 작성해도 `SSR`방식에 비해 데이터를 제대로 못 긁어가는 건 어쩔 수 없었다.

## 새로운 개념의 Server Side Rendering의 등장

`SSR`을 택하자니 `SPA`의 장점이 아깝고, `SPA`를 택하자니 `SSR`의 장점이 아깝다. 그럼 어떻게 해야 할까? 그래서 나온 방식이 최근에 많이 사용하고 있는 `두 방식을 적당히 짬뽕한 방식`이다. 사용자의 첫 요청시에만 `SSR`을 수행하고, 그 이후는 `SPA`처럼 동적인 렌더링을 수행하는 것이다. 이 방식은 아래와 같은 장점을 가진다.

**장점**

1. 첫 요청을 `SSR`로 완성된 HTML을 내려줌으로써 `SEO`와 초기 렌더링 속도문제를 해결
2. 이후 클라이언트에 렌더링을 수행함으로써 `SPA`의 장점인 페이지 이동 시 빠른 렌더 속도도 그대로 가져감.
3. Frontend 프레임워크 3대장인 `Angular`, `React`, `Vue` 모두 이러한 `SSR` 방식을 공식으로 지원하기 때문에 Client와 Server를 같은 Context로 묶을 수 있음. 즉 내가 만든 컴포넌트는 클라이언트에서 렌더를 수행하든 서버에서 렌더를 수행하든 동일하게 실행된다.

**단점**

1. 코드가 복잡하다. 어플레케이션 구동 순서를 확실하게 파악하고 있지 않다면 진짜 헷갈린다.
2. 서버에서 렌더링을 수행하므로 단순 리소스 서빙보다는 아무래도 CPU를 많이 사용하게 되고, 부하가 걸릴 수 있다.
3. 서버에 익숙하지 않은 Frontend 개발자의 경우 클라이언트처럼 개발을 진행하게 되면 의도하지 않은 버그가 생길 수 있다.

출처 : [https://evan-moon.github.io/2018/09/25/universal-ssr/](https://evan-moon.github.io/2018/09/25/universal-ssr/)
